#include <iostream>
#include <string>
#include <cstring>
using namespace std;
#define NMAX 51		// 입력 최대 값

typedef unsigned long long ll;
int n;
ll k;	/* 2^50-1d은 int 자료형 2^32-1이므로 범위를 넘어섬 */
ll dp[NMAX][NMAX * 2 + 1][2];

/* 괄호 ㄴㄴ 문자열 개수를 파악하는 함수 */
ll countNotBracket(int pos, int open, bool isTrue)
{
	/* 
		문자열 마지막 위치에서
		이전에 이미 괄호 ㄴㄴ 문자열임을 파악했거나 괄호 계산 ( '(' = + 1, ')' = -1 )에서 0이 나오지 않은 경우,
		괄호 ㄴㄴ 문자열로 판단해 1을 반환.
		그렇지 않고 괄호 계산에서 1이 나왔을 경우,
		괄호 문자열로 판단해 0을 반환
	*/
	if (pos == n)
		return isTrue || open != 0;

	/* 
		배열 첫 번째 : 문자열에서 현재 위치 ( 이전 위치 문자들은 결정이 완료된 상태 )
		배열 두 번째 : 문자열에서 현재 남은 열린 괄호 ( '(' )
		배열 세 번째 : 현재 문자열이 괄호 문자열인지, 괄호 ㄴㄴ 문자열인지 결정
		-> 현재 위치 pos에서 열린 괄호 개수가 open개 일 때, 괄호 ㄴㄴ 문자열 개수
		ex) n = 3일 때,
			(XX
			= dp[1][1][1] = 6
			= dp[1][1][0] = 2
		open + n의 이유 : 닫힌 괄호')'에 의해 open이 음수가 되어 배열에서 오류가 생기는 것을 방지하기 위함
	*/
	ll& cache = dp[pos][open + n][isTrue];

	/* 
		만일 이미 캐시에 값이 변경되어 있는 경우
		변경된 값을 그대로 반환 ( 이미 그 부분까지의 괄호 ㄴㄴ 문자열 개수가 계산되었기 때문 )
	*/
	if (cache != -1)
		return cache;

	/* 변경되지 않았을 경우 0으로 초기화 */
	cache = 0;
	/* 
		문자열의 현재 위치 문자를 열린 괄호'('로 결정했을 경우
		위치를 다음 칸으로 이동, 
		열린 괄호 개수 증가, 
		괄호 문자열 여부 변수는 변경 없이 재귀함수를 실행
	*/
	cache += countNotBracket(pos + 1, open + 1, isTrue);
	/* 
		문자열의 현재 위치 문자를 닫힌 괄호')'로 결정했을 경우
		위치를 다음 칸으로 이동,
		닫힌 괄호를 선택했으므로 열린 괄호 개수 감소,
		닫힌 괄호를 선택했기 때문에 현재 문자열이 괄호 문자열인지, 닫힌 괄호가 더 많은지를 판단함
			-> 열린 괄호 개수 open이 0 이하일 경우, 현재 문자열을 괄호 ㄴㄴ 문자열이라 생각함
		재귀함수 실행 
	*/
	cache += countNotBracket(pos + 1, open - 1, isTrue || open <= 0);
	/* 계산이 완료된 현재에 대한 괄호 ㄴㄴ 문자열 개수 반환 */
	return cache;
}

/* 괄호 ㄴㄴ 문자열 번호 cnt에 해당하는 괄호 ㄴㄴ 문자열을 반환하는 함수 */
string printNotBracket(int pos, int open, bool isTrue, ll cnt)
{
	/* 현재 위치가 마지막 문자 출력 전일 경우 */
	if (pos == n - 1)
	{
		/*
			문자열 번호 cnt가 1일 경우는 '(',
			문자열 번호 cnt가 2일 경우는 ')'를 뜻함
			사전 순서상 첫 번째 괄호 ㄴㄴ 문자열은 '(', 두 번째 괄호 ㄴㄴ 문자열은 ')'임
			이 법칙은 다른 괄호 ㄴㄴ 문자열을 만들때도 사용됨
		*/
		if (cnt == 1)
			return "(";	// 문자열 번호가 1일 경우 '('를 반환
		else
			return ")"; // 문자열 번호가 2일 경우 ')'를 반환
	}
	else
	{
		/* 다음 위치가 열린 괄호 '('일 때의 괄호 ㄴㄴ 문자열 개수 cache를 정의 */
		ll& cache = dp[pos + 1][open + n + 1][isTrue];
		/*
			만일 cache보다 현재 문자열 번호가 작을 경우
			현재 번호의 괄호 ㄴㄴ 문자열이 cache 번호의 괄호 ㄴㄴ 문자열보다 이전에 존재함을 알 수 있음
			그러므로 현재 문자에 대해 '('로 결정함 ( 사전 순서상 이전 )
		*/
		if (cache >= cnt)
			/*
				열린 괄호 문자를 사용했으므로 위치 이동, 열린 괄호 수 증가를 시켜줌
				또한, 현재 문자열 번호가 다음 cache에 포함되므로 현재 문자열 번호를 그대로 가져가
				재귀함수를 실행함
			*/
			return '(' + printNotBracket(pos + 1, open + 1, isTrue, cnt);
		/*
			만일 cache보다 현재 문자열 번호가 클 경우
			현재 번호의 괄호 ㄴㄴ 문자열이 cache 번호의 괄호 ㄴㄴ 문자열보다 이후에 존재함을 알 수 있음
			그러므로 현재 문자에 대해 ')'로 결정함 ( 사전 순서상 이후 )
		*/
		else
			/* 
				닫힌 괄호 문자를 사용했으므로 현재 문자열이 괄호 ㄴㄴ 문자열인지 아닌지 파악
				또한, 결정되지 않은 문자열을 제외한 앞의 문자열은 결정이 완료된 상태임
				그러므로 결정되지 않은 문자열의 번호 ( cnt - cache )를 기준으로 재귀함수를 실행함
			*/
			return ')' + printNotBracket(pos + 1, open - 1, isTrue || open <= 0, cnt - cache);
	}
}

int main()
{
	cin.tie(0);
	ios::sync_with_stdio(false);
	
	/* dp 배열의 모든 값을 -1로 초기화 */
	memset(dp, -1, sizeof(dp));
	
	/* 문자열 길이와 원하는 문자열 번호 입력 */
	cin >> n >> k;
	/* 입력된 길이만큼의 괄호 ㄴㄴ 문자열 개수 파악 */
	countNotBracket(0, 0, false);
	/* 
		만일 입력된 괄호 ㄴㄴ 문자열 번호가 계산된 괄호 ㄴㄴ 문자열 개수보다 많을 경우
		출력할 수 없으므로 -1을 출력
		(dp[0][n][0] = 길이 n에서 나올 수 있는 총 괄호 ㄴㄴ 문자열 개수)
		k + 1 인 이유 : ((((... 도 포함해주기 위함 ( 순서상 0번 )
	*/
	if (k + 1 > dp[0][n][0])
		cout << -1;
	else
		/* 그렇지 않을 경우 해당 번호의 괄호 ㄴㄴ 문자열을 출력함 */
		cout << printNotBracket(0, 0, 0, k + 1);

	return 0;
}